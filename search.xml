<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[我是怎么处理大小端及网络字节序的？]]></title>
    <url>%2F2018%2F01%2F03%2Fbyte-order%2F</url>
    <content type="text"><![CDATA[背景最开始接触c语言时，总会花很多精力去记各种操作符的优先级。后来才发现，实际开发根本就不用记。自此这么多年，除了加减乘除这种小学生都知道的优先级，我基本都是用括号搞定优先级。 同样，不同语言的字节序都不尽相同，比如c++大部分平台是小端存储的（c++的字节序与处理器有关系，具体大小端与编译器对应关系见参考文档1），java就是采用大端存储，c#似乎是小端存储（c#我写的少，有心人可以帮忙确认下）。在写跨语言或者跨平台的程序时，字节序的转换就不得不考虑了。 大端小端转换关于大端小端的由来，可以看看《格列佛游记》，我就不转载了。大端：数据的高位存储在低地址中，低位存储在高地址中。小端：数据的低位存储在高地址中，高位存储在低地址中。 举个例子，数据0x12345678，占4个字节，分别是0x12、0x34、0x56、0x78。假设内存起始地址是0x80000000。对于小端程序来说，0x80000000存放0x78，0x80000001存放0x56，0x80000002存放0x34，0x80000003存放0x12。而对于大端程序来说，0x80000000存放0x12，0x80000001存放0x34，0x80000002存放0x56，0x80000003存放0x78。 这里要说明的是，大小端只对多字节数据类型有影响，对于单字节类型的数组、字符串，并没有什么影响。另外如果是多个多字节数据放在一起，顺序依然不会变，只是每个多字节数据区分大端还是小端罢了。 所以，一般情况下，大小端字节序转换规则如下： 单字节数据或数组，不需要转换 少于或等于4字节的长整型，前后互换就行了。 还有三种特殊情况： 对于8字节的长整型int64来说，并不是前后字节互换，而是先将高32位和低32位互换，然后，将这两个int32内部字节位互换。 对于float类型来说，同样是前后字节对换。 尽管double是8字节的，但是其转换方式和float一样，也是前后字节兑换。 具体代码可参考poco，我就不贴出来了，参阅参考文献2。 怎么判断大端还是小端可能很多毕业生找工作时都会被问到如何判断当前系统是大端还是小端。知道原理后，实现起来其实很简单。定义一个多字节类型，然后判断不同地址的值，看看高地址存放的是高位数据还是低位数据，就能轻易区分当前是大端还是小端了。 实际工作中，就没必要这样判断了。因为不同平台上大小端是提前就知道的。如果使用poco库，完成可以依赖其Platform.h中的宏定义，里面还包含了我没有见过的平台。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#if defined(__ALPHA) || defined(__alpha) || defined(__alpha__) || defined(_M_ALPHA) #define POCO_ARCH POCO_ARCH_ALPHA #define POCO_ARCH_LITTLE_ENDIAN 1#elif defined(i386) || defined(__i386) || defined(__i386__) || defined(_M_IX86) || defined(EMSCRIPTEN) || defined(__EMSCRIPTEN__) #define POCO_ARCH POCO_ARCH_IA32 #define POCO_ARCH_LITTLE_ENDIAN 1#elif defined(_IA64) || defined(__IA64__) || defined(__ia64__) || defined(__ia64) || defined(_M_IA64) #define POCO_ARCH POCO_ARCH_IA64 #if defined(hpux) || defined(_hpux) #define POCO_ARCH_BIG_ENDIAN 1 #else #define POCO_ARCH_LITTLE_ENDIAN 1 #endif#elif defined(__x86_64__) || defined(_M_X64) #define POCO_ARCH POCO_ARCH_AMD64 #define POCO_ARCH_LITTLE_ENDIAN 1#elif defined(__mips__) || defined(__mips) || defined(__MIPS__) || defined(_M_MRX000) #define POCO_ARCH POCO_ARCH_MIPS #if defined(POCO_OS_FAMILY_WINDOWS) // Is this OK? Supports windows only little endian?? #define POCO_ARCH_LITTLE_ENDIAN 1 #elif defined(__MIPSEB__) || defined(_MIPSEB) || defined(__MIPSEB) #define POCO_ARCH_BIG_ENDIAN 1 #elif defined(__MIPSEL__) || defined(_MIPSEL) || defined(__MIPSEL) #define POCO_ARCH_LITTLE_ENDIAN 1 #else #error "MIPS but neither MIPSEL nor MIPSEB?" #endif#elif defined(__hppa) || defined(__hppa__) #define POCO_ARCH POCO_ARCH_HPPA #define POCO_ARCH_BIG_ENDIAN 1#elif defined(__PPC) || defined(__POWERPC__) || defined(__powerpc) || defined(__PPC__) || \ defined(__powerpc__) || defined(__ppc__) || defined(__ppc) || defined(_ARCH_PPC) || defined(_M_PPC) #define POCO_ARCH POCO_ARCH_PPC #if defined(__BYTE_ORDER__) &amp;&amp; (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) #define POCO_ARCH_LITTLE_ENDIAN 1 #else #define POCO_ARCH_BIG_ENDIAN 1 #endif#elif defined(_POWER) || defined(_ARCH_PWR) || defined(_ARCH_PWR2) || defined(_ARCH_PWR3) || \ defined(_ARCH_PWR4) || defined(__THW_RS6000) #define POCO_ARCH POCO_ARCH_POWER #define POCO_ARCH_BIG_ENDIAN 1#elif defined(__sparc__) || defined(__sparc) || defined(sparc) #define POCO_ARCH POCO_ARCH_SPARC #define POCO_ARCH_BIG_ENDIAN 1#elif defined(__arm__) || defined(__arm) || defined(ARM) || defined(_ARM_) || defined(__ARM__) || defined(_M_ARM) #define POCO_ARCH POCO_ARCH_ARM #if defined(__ARMEB__) #define POCO_ARCH_BIG_ENDIAN 1 #else #define POCO_ARCH_LITTLE_ENDIAN 1 #endif#elif defined(__arm64__) || defined(__arm64) #define POCO_ARCH POCO_ARCH_ARM64 #if defined(__ARMEB__) #define POCO_ARCH_BIG_ENDIAN 1 #elif defined(__BYTE_ORDER__) &amp;&amp; defined(__ORDER_BIG_ENDIAN__) &amp;&amp; __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ #define POCO_ARCH_BIG_ENDIAN 1 #else #define POCO_ARCH_LITTLE_ENDIAN 1 #endif#elif defined(__m68k__) #define POCO_ARCH POCO_ARCH_M68K #define POCO_ARCH_BIG_ENDIAN 1#elif defined(__s390__) #define POCO_ARCH POCO_ARCH_S390 #define POCO_ARCH_BIG_ENDIAN 1#elif defined(__sh__) || defined(__sh) || defined(SHx) || defined(_SHX_) #define POCO_ARCH POCO_ARCH_SH #if defined(__LITTLE_ENDIAN__) || (POCO_OS == POCO_OS_WINDOWS_CE) #define POCO_ARCH_LITTLE_ENDIAN 1 #else #define POCO_ARCH_BIG_ENDIAN 1 #endif#elif defined (nios2) || defined(__nios2) || defined(__nios2__) #define POCO_ARCH POCO_ARCH_NIOS2 #if defined(__nios2_little_endian) || defined(nios2_little_endian) || defined(__nios2_little_endian__) #define POCO_ARCH_LITTLE_ENDIAN 1 #else #define POCO_ARCH_BIG_ENDIAN 1 #endif#elif defined(__AARCH64EL__) #define POCO_ARCH POCO_ARCH_AARCH64 #define POCO_ARCH_LITTLE_ENDIAN 1#elif defined(__AARCH64EB__) #define POCO_ARCH POCO_ARCH_AARCH64 #define POCO_ARCH_BIG_ENDIAN 1#endif 如何将本地字节序转成网络字节序呢？本文最开始我提到，如果我们写代码时，不用考虑当前是大端还是小端，就方便极了。poco同样提供了封装：fromNetwork和toNetwork，可以在ByteOrder.h中找到。如果你的项目中没有使用poco，又不想因为大小端问题引入一个库，那问题也不大，无非就是根据大小端情况封装fromNetwork和toNetwork而已，具体实现就直接参考poco的实现就行了。 参考文档： https://github.com/pocoproject/poco/blob/develop/Foundation/include/Poco/Platform.h#L137 https://github.com/pocoproject/poco/blob/develop/Foundation/include/Poco/ByteOrder.h 本文链接：http://servercoder.com/2018/01/03/byte-order/]]></content>
  </entry>
  <entry>
    <title><![CDATA[跨平台开发时，我们为什么不封装http请求的sdk]]></title>
    <url>%2F2017%2F12%2F11%2Fsdk-without-http%2F</url>
    <content type="text"><![CDATA[为什么要封装sdk相信很多开发团队都同时需要开发各种平台的客户端，有android、ios，甚至是pc版客户端。于是，怎么尽可能复用同一套业务代码，成了很多开发讨论的话题。 比如，开发照片处理软件，核心的处理算法一定都是c++写的，除了计算效率高之外，算法的实现也肯定是很复杂的，不可能每个客户端都用各自编程语言实现一套。这样带来的好处有： 代码量更少，开发效率高。 减少了不同语言实现时产生相同bug的可能。 减少了因不同语言开发人员开发水平不一致，出现各种bug的可能。 后期维护更方便。 测试更方便。 同样地，当你引入一个新的通信库时，如grpc。它提供了不同语言的实现，java、go、c++。如果每个语言都基于grpc封装一套通信逻辑，意味着每个语言的人都要了解grpc的使用，如果要求高一点，我们对引入的第三方库一定要读懂核心代码，那耗费的时间就更多了。更别说后期维护的时间。 什么时候要封装sdk所以，我们到底什么时候该封装sdk呢？我认为出现下面几种情况，你可能就得考虑封装sdk了。 业务逻辑复杂，并且多平台客户端都需要。 复杂的算法。 网络通信中间件。比如我上面提到的grpc,还有一些基于tcp数据的封装、发送、解析。 多个项目可能会使用的公共模块。 http请求，是否要封装？我们常说的一句话，架构设计不能脱离业务。诚然，我们很多时候的技术选型都是在权衡，权衡开发成本，权衡产品状态，权衡现有开发人员的水平等等。有的时候具体问题还是要具体分析。上面说了那么多什么时候要封装sdk。那对于提供http接口的服务，有必要封装sdk吗？我认为如果只是封装http的请求和响应，而不包含其他业务逻辑时，必要性不大，原因如下： 如果将http的请求和相应封装成sdk，我们看看是否提高了开发效率。首先确实只有一处公共代码发起http请求和响应，但为此，需要为各个客户端封装接口，以便能调用sdk。比如，c#需要封装托管c++或是提供c语言形式地接口，然后c#在以invoke的方式调用。比如，java和andriod，我们需要封装jni接口。其他语言就更别说了，能间接调用c接口，但都要简单的封装。于是，后期我们每增加一个接口都需要修改sdk，需要修改调用接口。这样做提高效率了吗？有人可能会说，sdk中发起http请求和相应的代码复用了，我减少了开发和维护成本呢。 但不要忘记了，各个语言都有非常成熟且经过充分验证的http client api。也就是说，各个高级开发语言（除了c++）不需要额外的开发精力，我们就能实现稳定的http调用。 对于http服务来说，如果设计人员的水平还行的话，我们不可能需要频繁修改接口，更多的是新增接口。而对于新增接口而言，我们并没有节省什么开发成本。 你能保证你封装的接口一次性交付么？ 封装sdk可能带来的问题再说远一点，并不是说为了增加复用，提高开发效率就一定要封装sdk。如果是服务端开发人员，如果多个项目都包含同一份sdk，一旦该sdk出了问题，就意味着所有相关项目都需要重新升级部署。这个时候就该考虑服务化了，如果该sdk相关逻辑在一个单独的服务里面，我们只需要更新该服务就行，这样相关项目与那段逻辑就实现了解耦。沈剑的这篇文章《小小的公共库，大大的耦合，你痛过吗？》，大家可以关注下。 本文链接：http://servercoder.com/2017/12/11/sdk-without-http/]]></content>
  </entry>
</search>
